# 第三周总结

#### 技术栈：JavaScript+Css+Ajex

#### 学习内容总结

1.学习了css 盒子模型 内外布局 浮动特性

2.学习了JavaScript,为css之前制作的网页添加了交互效果

3.学习了Ajex

#### 遇到的问题

由于缺少一些相关的前置知识（），导致对于Ajex的理解以及具体应用场景不够深刻

#### 刷题

分发饼干
题目：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj>= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。

示例 1: 输入: [1,2,3],
[1,1] 输出: 1

解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。

示例 2: 输入: [1,2],
[1,2,3] 输出: 2

解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.

先用sort进行排序，接着while循环在不等于原数组的长度下，进行if判断，对应的指针后移。

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) 
    {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int res = 0;
        int i = 0;
        int j = 0;
        while(i != g.size() && j != s.size())
        {
            if(s[j] >= g[i])
            {
                res++;
                i++;
                j++;
            }
            else j++;
        }
        return res;
    }
};
```

无重叠区间
题目：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。
注意:可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:
输入: [ [1,2],
[2,3], [3,4], [1,3] ]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。

示例 2:
输入: [ [1,2],[1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

示例 3:
输入: [ [1,2],[2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

先用sort进行排序，从区间第一个数组的右端点left开始比较，如果当前区间的左端点小于 指针区间的右端点，说明重复，删掉。否则指针后移

```c
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) 
    {
        if(intervals.empty()) return 0;
        int n = intervals.size();
        sort(intervals.begin(), intervals.end());//
        int count = 0;
        int left = intervals[0][1];//从第一个区间的右端点开始
        for(int i = 1; i < n; i++)
        {
            //如果当前区间的左端点小于 指针区间的右端点，说明重复，删掉
            if(intervals[i][0] < left)
            {
                count++;
                left = min(left, intervals[i][1]);
            }
            //不重复则指针后移
            else left = intervals[i][1];
        }
        return count;
    }
};
```



